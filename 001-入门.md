# 第一章 入门

学习 C 语言的 **唯一有效途径** 就是使用它编写程序。对于初学者而言，编写的第一个程序几乎都是相同，即：向屏幕输出 `"hello, world!"`

现在，我们打开你最熟悉的文本编辑软件，然后输入下面给出的例程，最后将保存文件并为 `hello.c` 

```c title="hello.c"
/**
 * hello.c - A simple C program that prints "hello, world!" to the console.
 */

#include <stdio.h>

int main(void)
{
    printf("hello, world!\n");
    return 0;
}
```

> [!warning] 
>
> 我们使用 `.c` 作为 C 源文件的扩展名，表示这个文本文件中的保存的是由 C 语言编写的源程序
> 

现在，我们需要将 `hello.c` 这个 C 源程序 **翻译** 为计算机可以执行 **机器指令**。**机器指令** 与硬件高度相关的位模式，也称为二进制序列，它指导 CPU 完成工作。翻译任务由另一个被称为 **编译器** 的程序完成，它的输入是 C 源文件，输出是 **目标文件** 或 **可执行文件**

目前市面上常用的编译器有三种，适用于不同的操作系统

+ [Microsoft Visual Studio](https://visualstudio.microsoft.com/zh-hans/) 是 Windows 操作系统中最常使用的集成开发环境
+ [GCC](https://gcc.gnu.org/) 通常是 Linux/Unix 操作系统中默认编译器
+ [LLVM + Clang](https://clang.llvm.org/) 目前在 Linux/Unix 操作系统中的使用比例在快速上升

假设你正在 Linux 操作系统中工作，这里我们推荐使用 GCC 编译器。在 Linux 操作系统中安装 GCC 编译器非常简单，只需要使用对应发行版的包管理工具安装即可。作为新手，Ubuntu 是一个不错的选择

```shell
# 安装 GCC 编译器
sudo apt install build-essential 
```

现在，我们可以使用 GCC 编译器编译 `hello.c` 并运行


```shell
# 编译 hello.c 并将生成的可执行文件命名为 hello
$ gcc hello.c -o hello
# 运行 hello
$ ./hello
hello, world!
```

现在，我们详细且完整介绍 `hello.c` 中的每一行

## 1.1 理解 hello 程序

### 1.1.1 注释

首先，程序的最开始是由 `/*` 和 `*/` 包围的内容，这些内容被称为 **注释**，用于解释程序或者记录你当时的想法。相信我，你很快就会忘记当时所想，因此使用注释记录下来是非常有必要的

此外，从 C99 标准起允许使用双斜线 (`//`) 作为单行注释的开头。换句话说，从双斜线开始到当前行结束的内容都属于注释

```c hl:1
// hello.c - A simple C program that prints "hello, world!" to the console.

#include <stdio.h>

int main(void)
{
    printf("hello, world!\n");
    return 0;
}
```

### 1.1.2 预处理指令

在注释之后的一行是 **预处理指令**。**预处理** 是 C 程序正式编译之前的动作，它会删除 C 语言文件中的注释，并执行 **预处理指令**。预处理指令就是那些使用 `#` 开头的指令，预处理器会解释并执行它们。目前，我们只需要理解 `#inclde` 指令

> [!tip]
>
> `#include` 指令的作用是包含指定的文件。更具体的来说，就是将指定文件中的内容复制到 `#include` 指令所在的位置
> 

指定需要包含文件的方式有两种：`<...>` 或 `"..."`，它们的区别在于查找头文件的顺序。`<...>` 在编译环境设置的目录中查找，而 `"..."` 优先在当前工作目录中查找（相对于源文件），最后在编译环境设置的目录中查找

### 1.1.3 函数定义

语句 `int main(void) { ... }` 是函数定义语句；类型 `int` 表示函数的 **返回值类型**；`main(void)` 是 **函数声明符**，它声明了一个名字为 `main` 的函数，而 `(void)` 是函数参数列表，其中 `void` 表示空，即该函数不接收任何参数；`{ ... }` 是 **函数体**，即函数被调用时需要执行的所有语句

> [!tip]
>
> 在 C 语言中，`main()` 函数是一个特殊函数，它是 C 程序执行时第一个被调用的函数，换句话说，**`main()` 函数是 C 程序的入口**

### 1.1.4 函数调用

语句 `printf("hello, world!\n");` 调用函数 `printf()`，该函数需要接收一个参数 `"hello, world!\n"` 并且将该参数写入到标准输出

> [!tip]
>
> 用 **双引号** 括起来的字符序列称为 **字符串常量**，例如 `"hello, world!\n"` 就是一个字符串。
>

在 C 语言中，字符序列 `'\n'` 表示 **换行符**，它被称为 **转义字符序列**。注意，它只是一个字符

程序在输出字符时遇见 `'\n'`，输出将换行，从下一行的开始位置继续输出。请注意，`printf()` 函数想要输出换行符，必须在字符串中使用 `'\n'` 表示，因为 `printf()` 函数永远不会自动换行。基于这个特性，可以多次调用 `printf()` 函数

```c
#include <stdio.h>
 
int main(void)
{
    printf("hello, ");
    printf("world!");
    printf("\n");
    return 0;
}
```

### 1.1.5 返回值

语句 `return 0;` 用于从函数中返回值。这里，`main()` 函数结束时会返回 `0`

> [!tip]
>
> `main()` 函数的返回值通常用于表示程序的执行状态。如果程序执行正常结束，则 `main()` 函数返回 $0$；其他情况下，`main()` 函数则返回非零值

## 1.2 变量与算术表达式

使用公式 $\degree C = (5 / 9) (\degree F - 32)$ 可以将华氏温度转换为摄氏温度。根据这个公式，我们可以编写一个示例程序用于输出一个华氏温度与摄氏温度的对照表。这个示例程序将引入一些新概念，包括 **声明**、**变量**、**算术表达**、**循环** 以及 **格式化输出**

```c title="fahr2celsius.c"
/**
 * fahr2celsius.c - Convert Fahrenheit to Celsius.
 * Output of Fahrenheit vs. Celsius Temperature Control Table
 *
 * for fahr = 0, 20, ..., 300; integer arithmetic version
 */

#include <stdio.h>

int main(void)
{
    int fahr, celsius;
    int lower, upper, step;
    
    lower = 0;   // lower limit of fahrenheit temperature
    upper = 300; // upper limit of fahrenheit temperature
    step = 20;   // step size
    fahr = lower;

    while (fahr <= upper)
    {
        celsius = 5 * (fahr - 32) / 9;
        printf("%3d %6d\n", fahr, celsius);
        fahr = fahr + step;
    }
    return 0;
}
```

在 C 语言中，所有的 **变量** 都必须先声明后使用。**声明用于说明变量的属性**，它由一个 **类型名** 和一个 **变量表** 组成。例如

```c
int fahr, celsius;
int lower, upper, step;
```

类型 `int` 表示其后所列变量为整数，与之相对应的，类型 `float` 表示其后所列变量为浮点数（就是带有小数部分的数）。`int` 和 `float` 类型的取值范围取决于具体的机器。对于 `int` 类型，最典型的就是采用长度为 $32$ 位位模式表示；而 `float` 类型通常采用 $32$ 位的位模式表示，至少提供 $6$ 位有效数字（十进制）的精度

此外，C 语言还提供了其他一些基本类型

|类型|描述|
|:---|:---|
|`char`|字符，占 $1$ 字节|
|`short int`|短整型|
|`long int`|长整型|
|`long long int`|长长整型：C99 标准新增类型|
|`double`|双精度浮点数类型|
|`long double`|扩展精度浮点类型：C99 标准新增类型|

这些数据类型对象的大小也取决于具体的机器。另外，还存在这些基本类型的 **数组**、**结构**、**联合**、指向这类型对象的 **指针**、以及返回这些类型值的 **函数**

最开始指向的计算是下列 $4$ 个 **赋值语句**，它们为变量设置初始值。每条语句均以分号(`;`)结束

```c
lower = 0;   // lower limit of fahrenheit temperature
upper = 300; // upper limit of fahrenheit temperature
step = 20;   // step size
fahr = lower;
```

我们的温度表程序中，各行的计算方式相同，因此可以利用 **循环** 语句重复执行。这里我们选择使用 `while` 语句

```c hlt:"fahr <= upper"
while (fahr <= upper)
{
    ...
}
```

`while` 语句的执行方式为：首先，测试圆括号内的表达式；如果表达式的结果为任何 **非零值(`true`)**，则执行循环体；然后再重新测试圆括号内的表达式，如果表达式的结果仍然为真，则继续执行循环体；否则，结束循环。`while` 语句结束后，就会立即执行 `while` 语句后面的下一条语句

> [!warning]
>
> 在我们的示例程序中，`while` 语句的循环体是使用花括号括起来的一条或多条语句，它被称为 **块语句** 或者 **复合语句**。在 `while` 语句中的循环体，如果是块语句，则它等效为单条语句
>

换句话说，`while` 语句的循环体可以是不用花括号包括的单条语句

```c
while (i < j)
    i = 2 * i;
```

无论如何，我们都将受 `while` 控制的语句缩进一个制表位（通常采用 $4$ 个空格替代），这样可以提高代码可读性，程序员可以一眼看出那些语句属于 `while` 控制的语句

示例程序的大部分工作都是在循环体中完成的。循环体中的赋值语句

```c
celsius = 5 * (fahr - 32) / 9;
```

用于计算指定的华氏温度对应的摄氏温度，并将结果赋值给变量 `celsius`。请注意观察表达式 `celsius = 5 * (fahr - 32) / 9`，为什么没有按照华氏温度转摄氏温度的公式进行书写呢？即，为什么没有写出 `celsius = (5 / 9) * (fahr - 32)`？

> [!tip]
>
> 在 C 语言中，如果运算符 `/` 的两个操作数都是整数，那么结果也应该是整数，并且结果中的任何小数部分都会被舍弃
>
> 由于 $5$ 和 $9$ 都是整数，`5 / 9` 经过截断后的结果为 $0$，因此这一求得的所有摄氏温度都将为 $0$

示例程序还演示了 `printf()` 函数作为通用输出格式化函数。该函数的第一个参数是带输出的字符串，其中每个以百分号（`%`）开头的特殊序列称为 **格式符**，它们会被依次替换成 `printf()` 的其他实参。例如，`%d` 指定输出整型参数

```c
printf("%d\t%d\n", fahr, celsius); 
// 输出两个整数 fahr 和 celsius，中间保留一个使用水平制表符的空间
```

请注意，`printf()` 函数并不是 C 语言的一部分，它仅仅是标准库函数中的一个常用函数而已，这些标准库函数在任何 C 程序中都可以使用。此外，格式符还支持设置最小宽度和对齐方式（默认右对齐）。因此，可以用下面语句输出更好看的内容

```c
printf("%3d %6d\n", fahr, celsius);
```

目前，温度表示例程序还存在一个严重问题：温度表采用整数算术运算，计算得到的摄氏温度精度非常低（因为整数除法会截断小数部分）。为了得到更精确的结果，应该使用 **浮点算术运算** 替代整数算术运算。经过修改后的示例程序如下

```c title="fahr2celsius_float.c"
/**
 * fahr2celsius_float.c - Convert Fahrenheit to Celsius.
 * Output of Fahrenheit vs. Celsius Temperature Control Table
 *
 * for fahr = 0, 20, ..., 300; floating-point arithmetic version
 */

#include <stdio.h>

int main(void)
{
    float fahr, celsius;
    float lower, upper, step;
    lower = 0;   // lower limit of fahrenheit temperature
    upper = 300; // upper limit of fahrenheit temperature
    step = 20;   // step size

    fahr = lower;
    while (fahr <= upper)
    {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf("%3.2f %6.2f\n", fahr, celsius);
        fahr = fahr + step;
    }
    return 0;
}
```

## 1.3 for 语句

我们还可以使用 `for` 语句来编写温度表程序。

```c title="fahr2celsius_for.c"
/**
 * fahr2celsius_for.c - Convert Fahrenheit to Celsius.
 * Output of Fahrenheit vs. Celsius Temperature Control Table
 *
 * for fahr = 0, 20, ..., 300; floating-point arithmetic version
 */

#include <stdio.h>

int main(void)
{
    float fahr, celsius;
    float lower, upper, step;
    lower = 0;   // lower limit of fahrenheit temperature
    upper = 300; // upper limit of fahrenheit temperature
    step = 20;   // step size

    for (fahr = lower; fahr <= upper; fahr = fahr + step)
    {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf("%5.2f %9.2f\n", fahr, celsius);
    }
    return 0;
}
```

`for` 语句是另一种更为复杂的循环语句，是对 `while` 语句的推广。`for` 语句的圆括号内包含三个表达式，每个表达式使用分号隔开。

表达式 `fahr = lower` 是 `for` 语句的初始化部分，**仅在进入循环前执行一次**。表达式 `fahr <= upper` 是 `for` 语句的控制表达式，如果控制表达式的值为任何非零值，则执行循环体，否则结束 `for` 语句。

表达式 `fahr = fahr + step` 用于修改循环变量，该语句会在循环体执行完毕时执行。然后再次对控制表达式进行求值，如果控制表达式的值为任何非零在，则继续执行循环体，否则结束循环

```c title="reverse_fahr2celsius.c"
/**
 * reverse_fahr2celsius.c - Convert Celsius to Fahrenheit.
 * Output of Celsius vs. Fahrenheit Temperature Control Table
 * 
 * for celsius = 300, 280, ..., 0; floating-point arithmetic version
 */


#include <stdio.h>

int main(void)
{
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;
    upper = 300;
    step = 20;

    for (fahr = upper; fahr >= lower; fahr = fahr - step)
    {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf("%6.1f %6.1f\n", fahr, celsius);
    }
    return 0;
}
```

## 1.4 常量

在程序中使用 $300, 200$ 等类似 **幻数**（字面值） 并不是一个好习惯，它们几乎无法向阅读程序的人提供任何有效信息。处理幻数的一种有效方法就是赋予它们有意义的名字。C 语言中提供 **符号常量** 和 **constexpr**（从 C23 标准起引用，表示编译时常量）

### 1.4.1 符号常量

符号常量使用预处理指令 `#define`，它可以把 **符号名** 定义为一个特定的字符

```c
#define 名字 替换文本
```

程序中出现的所有 `#define` 中定义的名字（没有被引号引起来，也不是其他名字的一部分）都将使用对应的替换文本进行替换。**替换文本可以任何字符序列**

```c title="fahr2celsius.c"
/**
 * fahr2celsius.c - Convert Fahrenheit to Celsius.
 * Output of Fahrenheit vs. Celsius Temperature Control Table
 *
 * for fahr = 0, 20, ..., 300; flo arithmetic version
 */

#include <stdio.h>

#define FAHR_STEP 20
#define FAHR_LOWER 0
#define FAHR_UPPER 300


int main(void)
{
    float fahr, celsius;

    for (fahr = FAHR_LOWER; fahr <= FAHR_UPPER; fahr = fahr + FAHR_STEP)
    {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf("%6.1f %6.1f\n", fahr, celsius);
    }
    return 0;
}
```

经过预处理之后，`#define` 定义的符号只是简单使用替换文件进行替代。然而，使用 `#define` 定义符号常量也是有缺点的，因为它无法提供任何类型信息。

### 1.4.2 编译时常量

C23 标准引入关键字 `constexpr` 表示 **编译时常量表达式**，这意味着被 `constexpr` 会指示编译器在编译时求值，并且程序运行时就不再进行计算，直接使用编译时得到的结果

```c
#include <stdio.h>

int main(void)
{
    constexpr float fahr_lower = 0;
    constexpr float fahr_upper = 300;
    constexpr float fahr_step = 20;
    float fahr, celsius;

    for (fahr = fahr_lower; fahr <= fahr_upper; fahr = fahr + fahr_step)
    {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf("%6.1f %6.1f\n", fahr, celsius);
    }
    return 0;
}
```

> [!warning] 
> 
> `constexpr` 关键字可以为常量提供类型信息

## 1.5 数字系统

数字系统定义了如何使用特定的数字符号来表示一个数字。在不同的数字系统中，同一个数字有不同的表示方式。例如，

$$
(1111\ 0101\ 1011\ 1001\ 1110\ 0001)_{2}
$$

这样表示的数字称为 **二进制数字系统**，即使用 $\{0, 1\}$ 两个符号表示数字。如果将这个数字转换为 **十进制数字系统**，即使用 $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ 共 $10$ 个符号表示，结果为

$$
(16\ 103\ 905)_{10}
$$

使用十进制数字系统表示只需要 $8$ 个数字，而使用二进制数字系统表示需要使用 $24$ 位。显然，十进制数字系统可以使用更少的数字表示一个值。

> [!tip]
>
> 这里演示的数字系统称为 **位置化数字系统**，数字中符号占据的位置决定了其表示的值。位置化数字系统是最常用的数字系统

### 1.5.1 十进制数字系统

十进制（`decimal`）数字系统采用$\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ 共 $10$ 个符号表示一个数字，这些符号被称为 **十进制数码**，简称为 **数码**

> [!tip]
>
> 默认情况下，数字采用十进制数字系统表示。其他进制的数字必须使用 $(\text{number})_{\text{system}}$ 形式表示

在十进制数字系统中，数码在数字中的位置存在一个权重，称为 **位置量**，它是 $10$ 的幂。下图显示了十进制系统中使用位置量表示一个整数

![260120224150785.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1768920110807.png)

例如，十进制数字 $224$ 表示的值是

$$
224 = 2 \times 10^2 + 2 \times 10 + 4 \times 10 ^ 0
$$


如果需要表示小数，则小数部分使用的位置量是 **负指数** 的。换句话说，例如 $23.403$ 表示的值为

$$
23.403 = 2 \times 10^1 + 3 \times 10^0 + 4 \times 10^{-1} + 0 \times 10^{-2} + 3 \times 10^{-3}
$$


### 1.5.2 二进制数字系统

二进制（`binary`）数字系统采用$\{0, 1\}$ 共 $2$ 个符号表示一个数字，这些符号被称为 **二进制数码** 或 **位**

> [!tip]
>
> 数据和程序都是以 **二进制模式**（**位模式**，位串）存储在计算机中。这是因为计算机由一系列电子开关控制，它仅有开和关两种状态。分别使用 $0$ 或 $1$ 表示两种不同的状态
>

二进制数字系统中的数字也是使用 **位置量**，只是基数变为了 $2$。例如，二进制数 $(11001)_2$ 表示的值为

$$
(11001)_2 = 1 \times 2^{4} + 1 \times 2^{3} + 0 \times 2^{2} +  0 \times 2^{1} + 1 \times 2^{0} 
$$

### 1.5.3 十六进制数字系统

尽管计算机中采用二进制存储数据，但是它并不便于在计算机外部表示数字，因为二进制符号太长了。然而，十进制并不能有效像二进制那样直接显示存储在计算机中的内容。并且，二进制数和十进制数之间没有任何显然的关系

为了克服上述问题，发明了 **十六进制** 和 **八进制**。这里我们首先讨论十六进制（`hexadecimal`）数字系统。在十六进制数字系统中，采用$\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\}$ 共 $16$ 个符号表示一个数字，这些符号被称为 **十六进制数码**。其中，$A \sim F$ 分别表示 $10 \sim 15$

十六进制数字系统中的数字也是使用 **位置量**，只是基数变为了 $16$。例如，十六进制数 $(2AE)_{16}$ 表示的值为

$$
(2AE)_{16} = 2 \times 16^{2} + 10 \times 16^{1} + 14 \times 16^{0} = 686
$$

### 1.5.4 八进制数字系统

在八进制（`octal`）数字系统中，采用$\{0, 1, 2, 3, 4, 5, 6, 7\}$ 共 $8$ 个符号表示一个数字，这些符号被称为 **八进制数码**

八进制数字系统中的数字也是使用 **位置量**，只是基数变为了 $8$。例如，八进制数 $(1256)_{8}$ 表示的值为

$$
(1256)_{8} = 1 \times 8 ^ 3 + 2 \times 8 ^ 2 + 5 \times 8^1 + 6 \times 8 ^ 0 = 686
$$

### 1.5.5 进制转换

#### 十进制与其他进制之间的相互转换

其他进制向十进制转换简单且迅速，只需要将数码与对应的位置量相乘后再相加即可。

十进制到其他进制的转换需要分为整数部分和小数部分分别进行。对于整数部分，采取的是 **除基数，余数逆序排列**。更具体来说，将十进制数除以基数，记录余数（0或1），然后用得到的商继续除以基数，直到商为 $0$。例如，将十进制数 $35$ 转换为二进制数为 $(100011)_{2}$

$$
\begin{aligned}
&35 \div 2 = 17 \cdots 1 \\
&17 \div 2 = 8 \cdots 1  \\
& 8 \div 2 = 4 \cdots 0  \\
& 4 \div 2 = 2 \cdots 0  \\
& 2 \div 2 = 1 \cdots 0  \\
& 1 \div 2 = 0 \cdots 1  \\
\end{aligned}
$$

对于小数部分，采取的是 **乘以基数，取整数部分顺序排列**。更具体来说，将十进制数的小数部分乘以基数，取整数部分，然后用小数部分继续乘以基数，直到小数部分为 $0$ 或满足精度要求。例如，将十进制数 $0.634$ 转换为八进制数（精确到 4 位小数）的结果为 $(0.5044)_8$

$$
\begin{aligned}
&0.634 \times 8 = 5.072  \\
&0.072 \times 8 = 0.576  \\
&0.576 \times 8 = 4.608  \\
&0.608 \times 8 = 4.864  \\
\end{aligned}
$$

#### 二进制-八进制-十六进制之间的相互转换

二进制数码与八进制数码和十六进制数码存在显著关系。即

+ $1$ 个八进制数码需要使用 $3$ 个二进制数码表示
+ $1$ 个十六进制数码需要使用 $4$ 个二进制数码表示

根据这个关系，可以非常轻松的完成二进制-八进制-十六进制之间的相互转换。下图展示了转换过程

![1769526642986.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769526643011.png)

## 1.6 信息存储

在前面的示例程序中，我们使用了整数、浮点数以及字符串。那么这些数据是如何存储在计算机中的呢？

计算机中采用 **位模式** 存储数据。**位** 就是 $0$ 或 $1$，**位模式** 就是固定长度的位串。单纯的位模式并不能表示任何含义，我们需要给予位模式某种 **解释**。

> [!tip] 
>
> 解释就是某种映射，将位模式转换为我们需要数据类型的值。例如，无符号整数就是将位模式映射成非负整数。
>

现代计算机中，位模式按照 $8$ 位进行分组，称为 $1$ 字节。如果使用十六进制表示，$1$ 字节能够表示的数值范围是 $(00)_{16} \sim (FF)_{16}$。

每条计算机都有一个 **字长**，指明指针数据的标称大小。因为虚拟地址是这样的一个字来编码的，所以字长决定的最重要的系统参数是虚拟地址的最大大小。换句话说，一个字长为 $w$ 的机器而言，虚拟地址的范围是 $0 \sim 2^{w} - 1$，程序最多访问 $2^{w}$ 个字节

### 1.6.1 字节序

对于需要多个字节才能表示的程序对象，这里需要确定两个规则：对象的地址是什么？在内存中如何排列这些字节？在几乎所有的机器上，多字节对象都被存储为连续的字节序列，**对象的地址为所使用字节中最小的地址**。例如，假设有一个 `int` 类型（假设 `int` 类型为 $32$ 位模式表示）的变量 `x`，其地址为 `0x100`，这意味着从地址为 ` 0x100` 起的连续的 $4$ 字节， 都将用于存储变量 `x`

如果一个 $n$ 位的整数，其位表示为 $[x_{n-1}, x_{n-2}, \cdots, x_{1}, x_{0}]$，其中 $x_{n-1}$ 是最高有效位，而 $x_{0}$ 是最低有效位。如果按照 $8$ 位进行分组，则 **最高有效字节** 包括 $[x_{n-1},x_{n-2},\cdots,x_{w-8}]$，而 **最低有效字节** 包括 $[x_{7}, x_{6}, \cdots,x_{0}]$。

> [!tip] 
>
> 排列表示一个对象的字节有两个通用规则：
>
> + 某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，这种规则称为 **小端法**
> + 另一些机器则按照最高有效值字节到最低有效字节的顺序存储对象，这种规则称为 **大端法**

假设变量 `x` 的类型是 `int`，位于地址 `0x100` 处，它的十六进制值为 `0x01234567`。地址范围 $0x100 \sim 0x103$ 的字节顺序依赖于机器类型

![1769436133278.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769436133301.png)

### 1.6.2 无符号整数

使用下面的映射将位模式 $\vec b = [x_{n-1}, x_{n-2}, \cdots, x_{2},x_{1},x_{0}]$ 映射成一个无符号整数

$$
\begin{aligned}
B2U_{n}(\vec{b}) &= B2U_{n}([x_{n-1}, x_{n-2}, \cdots, x_{2},x_{1},x_{0}])\\
&= \sum_{i=0}^{n-1} x_{i}\cdot 2^{i}
\end{aligned}
$$

下面展示了几种情况下 $B2U$ 将位模式映射成无符号整数

$$
\begin{aligned}
B2U_{4}([0001]) &= 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 1 \\
B2U_{4}([0101]) &= 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 5 \\
B2U_{4}([1011]) &= 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 11
\end{aligned}
$$

> [!tip]
>
> 显然，使用无符号整数编码 $n$ 位位模式时，最小值在所有位均为 $UMin_{n} = 0$ 时取得，最小值为为 $0$；而最大值在所有位均为 $1$ 时取得，其最大值为 $UMax_{n} = 2^{n}-1$
>

### 1.6.3 补码编码

补码编码将位模式映射为整数，包括负整数、零和正整数。补码编码的定义如下

$$
\begin{aligned}
B2T_{n}(\vec{b}) &= B2T_{n}([x_{n-1}, x_{n-2}, \cdots, x_{2},x_{1},x_{0}])\\
&= -x_{n-1}\cdot 2^{n-1} + \sum_{i=0}^{n-2} x_{i}\cdot 2^{i}
\end{aligned}
$$

在补码编码中，最高位的权重是 $-2^{n-1}$。这与无符号编码相似，区别就在于此。下面展示了几种情况下 $B2T$ 将位模式映射成整数的示例

$$
\begin{aligned}
B2T_{4}([0001]) &= 0 \cdot -2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 1 \\
B2T_{4}([0101]) &= 0 \cdot -2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 5 \\
B2T_{4}([1011]) &= 1 \cdot -2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -5
\end{aligned}
$$

> [!tip]
>
> 在补码编码中，长度为 $n$ 的位模式能够表示的最小值为 $TMin_{n} = -2^{n-1}$，即位模式中只有最高位是 $1$ 其余位全是 $0$；最大值为 $TMax_{n} = 2^{n-1}-1$，即最高有效位为 $0$，其余位为 $1$

---
<center style="font-weight: bold; font-size: 18px;">负数补码的计算方法</center>

> [!warning] 
> 计算机中采用补码编码表示整数的一个重要原因就是 CPU 将使用加法器来实现减法。这是由于计算机内部表示整数的位模式长度都是固定的。例如，两个 `int` 类型的变量相加，其结果依旧是 `int` 类型，这是一种 **模算数** 系统
>
> 在有限的正整数域 $M = \{x \vert 0 \le x \lt m, x \in N\}$ 中，如果 $a + b = m$ 其中 $a \in M, b \in M$，则 $m \mod m = 0 = a + b$，而且 $b = -a (\mod m)$。也就是说，在数域 $M$ 中 $b$ 剋用来表示 $-a$，因此 $x - a = (x + b) \mod m$
>
> 在有限集合 $M$ 中，如果定义了 $+$ 运算，并且 $a + b = 0, a \in M, b \in M$，$0$ 是集合 $M$ 中的 **零元**，这称 $a$ 与 $b$ 互为逆元。这种互为逆元的数称为 **补数**

下面我们来讨论如何计算一个固定进制和位数的数的补数。在此之前，需要补充两个定义。对于 $n$ 位 $r$ 进制数 $a$，规定

+ $r^n - a$ 称为 $r$ 进制数 $a$ 关于基数的补数，简称为 $r$ 的补数
+ $r^n - 1 -a$ 称为 $r$ 进制数 $a$ 关于减基数的补数（减补数），即 $r-1$ 的补数

下面我们将 $n$ 位 $r$ 进制数 $a$ 展开表示为

$$
\begin{aligned}
a &= a_{n-1}r^{n-1} + a_{n-2}r^{n-2} + \cdots + a_{1}r^{1} + a_0r^{0}\\
&= \sum_{i=0}^{n-1}a_ir^i
\end{aligned}
$$

根据基数的补数定义，有

$$
\begin{aligned}
a + b &= r^n\\
\sum_{i=0}^{n-1}a_ir^i + b &= r^n \\
&= \sum_{i=0}^{n-1}(r-1)r^i + 1 \\
b &= \sum_{i=0}^{n-1}(r-1)r^i - \sum_{i=0}^{n-1}a_ir^i + 1\\
&= \sum_{i=0}^{n-1}(r-1-a_i)r^i + 1
\end{aligned}
$$

$n$ 位 $r$ 进制数 $a$ 关于基数的补数的每一位就是 $r - 1 - a_i$，最后再加上 $1$。在二进制下 $r = 2$，此时基数的补数，即 **二补数**，它就是之前介绍的 **补码**。不难发现，二进制下 $111\cdots 1 - a_{n-1}a_{n-2}\cdots a_{1}a_{0}$ 的结果就是将二进制数 $a$  **按位取反之后再加上 $1$** 即可

例如，需要计算 $-12$ 的补码编码的位模式，只需要计算 $12$ 的位模式，然后按位取反再加上 $1$ 即可。假设，这里我们采用 $8$ 位位模式表示

$$
\begin{aligned}
12 \div 2 &= 6 \cdots 0\\
 6 \div 2 &= 3 \cdots 0\\
 3 \div 2 &= 1 \cdots 1\\
 1 \div 2 &= 0 \cdots 1\\

 (12)_{10} &= (0000\ 1100)_{2} \\
(-12)_{10} &= (1111\ 0100)_{2}
\end{aligned}
$$

---

### 1.6.3 浮点数编码

浮点表示对形如 $V = x \times 2^y$ 的有理数进行编码。它对执行涉及非常大的数字或非常接近于 $0$ 的数字，以及更普遍的实数运算的 **近似值** 的计算，是很有用的。

大部分现代计算机中，浮点表示规则采用 IEEE 754 表示规则。IEEE 754 标准使用 $V = (-1)^{s} \times M \times 2^{E}$ 来表示一个数。其中

+ 符号(sign) `s` 决定这个数是负数($s=1$)还是正数($s=0$)，对于数字 $0$ 的符号位解释作为特殊情况
+ 尾数(significand) `M` 是一个 **二进制小数**，它的范围是 $1 \sim 2-\varepsilon$，或者 $0 \sim 1 - \varepsilon$。其中，$\varepsilon \rightarrow 0$
+ 阶码(exponent) `E` 的作用是对浮点数进行加权，这个权重是 $2^E$

显然，表示浮点数的位模式需要划分为三个字段，分别对上述值进行编码。IEEE 754 定义了多种格式的浮点数编码，最常用的 **单精度浮点数编码** 和 **双精度浮点数编码**，下图描述了这两种浮点数编码各个字段占用的位数

![1769440869918.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769440869949.png)

对于给定位表示，根据指数 `E` 的值，被编码的值可以分为四种不同的情况，下图使用单精度浮点格式说明具体的情况

![1769441613859.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769441613885.png)

<center style="font-weight: bold; font-size: 18px;">规格化浮点数</center>

规格化的值是最普遍的情况。当指数字段 `E` 的位模式即不全为 $0$(数值 $0$)，也不全为 $1$(单精度：数值 $255$；双精度：数值 $2047$)时，都属于这种情况。此时，指数字段的位模式被解释为以 **偏置(biased)** 形式表示的有符号整数。换句话说，指数字段表示的值为 $E = e - Bias$，其中 $e$ 是无符号数，而 $Bias$ 是一个等于 $2^{k-1} - 1$(单精度：$2^{8-1}-1 = 127$；双精度：$2^{11-1}-1=1023$) 的偏置值，由此产生的指数的取值范围，对于单精度是 $-126 \sim +127$，而对于双精度是 $-1022 \sim +1023$

尾数字段 `M` 被解释为 $0 \le M \lt 1$ 的值，二进制表示为 $0.m_{n-1}m_{n-2}\cdots m_{1}m_{0}$，也就是二进制小数点再最高有效位的左边。尾数定义为 $1 + M$，这也称为 **隐含以 $1$ 开头的表示**，这表示可以获得一个额外精度位，既然第一位总是等于 $1$，那么我们就不需要显式表示它

---
<center style="font-weight: bold; font-size: 18px;">非规格化浮点数</center>

当指数字段 `E` 的位模式全是 $0$ 时，所表示的数时非规格化形式。再这种情况下，指数位的值是 $E = 1-Bias$，而尾数字段 **不隐含开头的 $1$**

> [!tip]
> 
> 非规格化浮点数的指数设置为 $1-Bias$ 而不是 $-Bias$ 的原因是它提供了一种从非规格化值平滑转换到规格化值的方法

非规格化数有两种用途

+ 提供了一种表示数值 $0$ 的方法。因为规格化数要求的尾数是 $1 + M \ge 1$。因此，规格化数不能表示 $0$
+ 表示非常接近于 $0$ 的数。它们提供了一种 **逐渐溢出** 的属性

---
<center style="font-weight: bold; font-size: 18px;">特殊值</center>
当指数字段 `E` 的位模式全是 $1$ 时，根据尾数字段 `M` 的位模式情况，提供了两个特殊值

+ $\pm \infty$：尾数字段 `M` 的位模式全是 $0$
+ $NaN$：尾数字段 `M` 的位模式不全为 $1$

下表列出一些重要的单精度和双精度浮点数表示和数值

| 描述      | 指数            | 尾数            | 单精度                                                    | 双精度                                                      |
| :------ | :------------ | :------------ | ------------------------------------------------------ | -------------------------------------------------------- |
| $0$     | $00\cdots 00$ | $00\cdots 00$ | $2^{-126}\times 0=0.0$                                 | $2^{-1022}\times 0=0.0$                                  |
| 最小非规格化数 | $00\cdots 00$ | $00\cdots 01$ | $2^{-126}\times 2^{-23}\approx 1.4\times 10^{-45}$     | $2^{-1022}\times 2^{-52} \approx = 4.9\times 10^{-324}$  |
| 最大非规格化数 | $00\cdots 00$ | $11\cdots 11$ | $2^{-126}\times (1-2^{-23})\approx 1.2\times 10^{-38}$ | $2^{-1022}\times (1-2^{-51})\approx 2.2\times 10^{-308}$ |
| 最小规格化数  | $00\cdots 01$ | $00\cdots 00$ | $2^{1-127}\times 1 = 1.2 \times 10^{-38}$              | $2^{1-1023} \times 1 = 2.2\times 10^{-308}$              |
| $1$     | $01\cdots 11$ | $00\cdots 00$ | $2^{2^{7}-1-127} \times 1 = 0.0$                       | $2^{2^{10}-1-1023} \times 1 = 0.0$                       |
| 最大规格化数  | $11\cdots 10$ | $11\cdots 11$ | $2^{127}\times (2-2^{-23})\approx 3.4\times 10^{38}$   | $2^{1023}\times (2-2^{-51})\approx 1.8\times 10^{308}$   |

> [!tip]
> 
> 二进制小数 $0.11111111111111111111111$ 的值为 $\sum_{i=0}^{23} 2^{-1} = 1 - 2^{-23}$

### 1.6.4 字符编码

我们知道计算机中的所有数据都是使用位模式表示的，字符也不例外。也就是说，每个字符都对应一个独特的位模式，这个位模式对应的无符号整数值被称为字符的 **代码点**。将位模式转换为字符的映射有许多，其中最常用的是 ASCII(美国信息交换标准码) 和 Unicode(统一码)等。

位模式的长度取决于能够表示字符的个数，但是它们之间的关系不是线性的，而是对数关系。也就是说， $n$ 个字符需要长度为 $\log n$ 的位模式才能表示。
#### ASCII

ASCII 字符集采用长度为 $7$ 的位模式表示字符，即 ASCII 字符集中定义了 $2^7 = 128$ 个不同的字符。下表列出了 ASCII 值于字符的对应关系

| ASCII       | 控制字符       |     | ASCII       | 字符          |     | ASCII       | 字符    |     | ASCII       | 字符      |
| ----------- | ---------- | --- | ----------- | ----------- | --- | ----------- | ----- | --- | ----------- | ------- |
| $(00)_{16}$ | NULL(空)    |     | $(20)_{16}$ | **(space)** |     | $(40)_{16}$ | @     |     | $(60)_{16}$ | 、       |
| $(01)_{16}$ | SOH(标题开始)  |     | $(21)_{16}$ | !           |     | $(41)_{16}$ | **A** |     | $(61)_{16}$ | **a**   |
| $(02)_{16}$ | STX(正文开始)  |     | $(22)_{16}$ | "           |     | $(42)_{16}$ | **B** |     | $(62)_{16}$ | **b**   |
| $(03)_{16}$ | ETX(正文结束)  |     | $(23)_{16}$ | #           |     | $(43)_{16}$ | **C** |     | $(63)_{16}$ | **c**   |
| $(04)_{16}$ | EOT(传输终止)  |     | $(24)_{16}$ | $           |     | $(44)_{16}$ | **D** |     | $(64)_{16}$ | **d**   |
| $(05)_{16}$ | ENQ(请求)    |     | $(25)_{16}$ | %           |     | $(45)_{16}$ | **E** |     | $(65)_{16}$ | **e**   |
| $(06)_{16}$ | ACK(响应)    |     | $(26)_{16}$ | &           |     | $(46)_{16}$ | **F** |     | $(66)_{16}$ | **f**   |
| $(07)_{16}$ | BEL(响铃)    |     | $(27)_{16}$ | ,           |     | $(47)_{16}$ | **G** |     | $(67)_{16}$ | **g**   |
| $(08)_{16}$ | BS(退格)     |     | $(28)_{16}$ | (           |     | $(48)_{16}$ | **H** |     | $(68)_{16}$ | **h**   |
| $(09)_{16}$ | HT(水平制表符)  |     | $(29)_{16}$ | )           |     | $(49)_{16}$ | **I** |     | $(69)_{16}$ | **i**   |
| $(0A)_{16}$ | LF(换行)     |     | $(2A)_{16}$ | *           |     | $(4A)_{16}$ | **J** |     | $(6A)_{16}$ | **j**   |
| $(0B)_{16}$ | VT(垂直制表符)  |     | $(2B)_{16}$ | +           |     | $(4B)_{16}$ | **K** |     | $(6B)_{16}$ | **k**   |
| $(0C)_{16}$ | FF(换页)     |     | $(2C)_{16}$ | ,           |     | $(4C)_{16}$ | **L** |     | $(6C)_{16}$ | **l**   |
| $(0D)_{16}$ | CR(回车)     |     | $(2D)_{16}$ | -           |     | $(4D)_{16}$ | **M** |     | $(6D)_{16}$ | **m**   |
| $(0E)_{16}$ | SO(不用切换)   |     | $(2E)_{16}$ | .           |     | $(4E)_{16}$ | **N** |     | $(6E)_{16}$ | **n**   |
| $(0F)_{16}$ | SI(启用切换)   |     | $(2F)_{16}$ | /           |     | $(4F)_{16}$ | **O** |     | $(6F)_{16}$ | **o**   |
| $(10)_{16}$ | DLE(空格)    |     | $(30)_{16}$ | **0**       |     | $(50)_{16}$ | **P** |     | $(70)_{16}$ | **p**   |
| $(11)_{16}$ | DCI(设备控制1) |     | $(31)_{16}$ | **1**       |     | $(51)_{16}$ | **Q** |     | $(71)_{16}$ | **q**   |
| $(12)_{16}$ | DC2(设备控制2) |     | $(32)_{16}$ | **2**       |     | $(52)_{16}$ | **R** |     | $(72)_{16}$ | **r**   |
| $(13)_{16}$ | DC3(设备控制3) |     | $(33)_{16}$ | **3**       |     | $(53)_{16}$ | **S** |     | $(73)_{16}$ | **s**   |
| $(14)_{16}$ | DC4(设备控制4) |     | $(34)_{16}$ | **4**       |     | $(54)_{16}$ | **T** |     | $(74)_{16}$ | **t**   |
| $(15)_{16}$ | NAK(无响应)   |     | $(35)_{16}$ | **5**       |     | $(55)_{16}$ | **U** |     | $(75)_{16}$ | **u**   |
| $(16)_{16}$ | SYN(空转同步)  |     | $(36)_{16}$ | **6**       |     | $(56)_{16}$ | **V** |     | $(76)_{16}$ | **v**   |
| $(17)_{16}$ | ETB(传输块结束) |     | $(37)_{16}$ | **7**       |     | $(57)_{16}$ | **W** |     | $(77)_{16}$ | **w**   |
| $(18)_{16}$ | CAN(取消)    |     | $(38)_{16}$ | **8**       |     | $(58)_{16}$ | **X** |     | $(78)_{16}$ | **x**   |
| $(19)_{16}$ | EM(已到介质尾)  |     | $(39)_{16}$ | **9**       |     | $(59)_{16}$ | **Y** |     | $(79)_{16}$ | **y**   |
| $(1A)_{16}$ | SUB(替换)    |     | $(3A)_{16}$ | :           |     | $(5A)_{16}$ | **Z** |     | $(7A)_{16}$ | **z**   |
| $(1B)_{16}$ | ESC(溢出)    |     | $(3B)_{16}$ | ;           |     | $(5B)_{16}$ | [     |     | $(7B)_{16}$ | {       |
| $(1C)_{16}$ | FS(文件分隔符)  |     | $(3C)_{16}$ | <           |     | $(5C)_{16}$ | \     |     | $(7C)_{16}$ | \|      |
| $(1D)_{16}$ | GS(组分隔符)   |     | $(3D)_{16}$ | =           |     | $(5D)_{16}$ | ]     |     | $(7D)_{16}$ | }       |
| $(1E)_{16}$ | RS(记录分隔符)  |     | $(3E)_{16}$ | >           |     | $(5E)_{16}$ | ^     |     | $(7E)_{16}$ | `       |
| $(1F)_{16}$ | US(单元分隔符)  |     | $(3F)_{16}$ | ?           |     | $(5F)_{16}$ | _     |     | $(7F)_{16}$ | DEL(删除) |

#### Unicode

最开始使用的编码系统只有 ASCII，随着计算机再全球的普及，各个地区都定义自己的编码系统。这样就导致各地区的字符不能统一处理。为了克服这一困难，Unicode 协会建立一个通用的编码系统，提供了全面的字符集，称为 **Unicode(统一字符编码)**

起初，Unicode 采用 $2$ 字节位模式进行编码，后来 Unicode 的第 $5$ 版改成了 $4$ 字节位模式进行编码，并且 Unicode 与 ASCII(也称基本 Latin) 和 扩展 ASCII(也称为 Latin-1) 兼容。ASCII 码在 Unicode 码中高 $25$ 位设为 $0$，而扩展 ASCII 码在 Unicode 中高 $24$ 位设为 $0$

![1769607469088.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769607469109.png)

Unicode 字符集中的每一个代码都需要使用 $4$ 个字节。然而，许多字符的位模式大部分都是 $0$。如果完整的存储这些字符就会造成极大的空间浪费。一个字符的 Unicode 代码是确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于 **节省空间** 的目的，对 Unicode 协会定义了几种 **Unicode 转换格式（Unicode Transformation Format，简称为UTF）**，UTF-8(8-bit Unicode Transformation Format)、 UTF-16(16-bit Unicode Transformation Format)、UTF-32(32-bit Unicode Transformation Format)。它们之间的区别在表示一个字符最少需要占用的位模式长度。其中，UTF-8 是最常用的 Unicode 转换格式。下面介绍了 UTF-8 根据 Unicode 代码值的不同返回采用不同的编码模式

```shell
U+0000 .... U+007F(0 ~ 127)      0xxxxxxx
U+0080 .... U+07FF(128~2047)     110xxxxx 10xxxxxx
U+0800 .... U+FFFF(2048~65535)   1110xxxx 10xxxxxx 10xxxxxx
```

我们来看一下字符串 `"hello, 世界!"` 中没有字符的 UTF-8 编码

```c
字符串: "hello, 世界!"

字符 编号(hex)  位模式                 UTF-8
h    68        01101000              01101000
e    65        01100101              01100101
l    6c        01101100              01101100
l    6c        01101100              01101100
o    6f        01101111              01101111
,    2c        00101100              00101100
     20        00100000              00100000
世   4E16      01001110 00010110     11100100 10111000 10010110
界   754C      01110101 01001100     11100111 10010101 10001100
!    21        00100001              00100001
```

## 1.7 字符输入/输出

接下来，介绍一组与字符型数据处理有关的程序。C 语言标准库提供的以 **文本流** 方式处理的 IO 模型。文本流是由多行字符构成的字符序列，而每行字符则由 0个或多个字符组成，行末是一个换行符。标准库负责使每个输入／输出流都能够遵守这一模型。使用标准库的 C 语言程序员不必关心在程序之外这些行是如何表示的。

标准库提供了一次读/写一个字符的函数`getchar()`和`putchar()`。调用 `ch = getchar()`函数将从文本流（通常是通过键盘输入的）读取下一个输入字符，并将其作为返回值，如果读取失败返回 `EOF(End Of File)`；`putchar(ch)`将 **整型** 变量`ch`以字符的形式打印出来（通常是显示在屏幕上）

### 1.7.1 文件拷贝

借助 `getchar()` 和 `putchar()` 两个函数，可以在不了解其它输入／输出知识的情况下编写出许多有用的代码。例如，**拷贝文件**，其核心逻辑就是不断的执行 `getchar()` ，检查是否是 `EOF`，然后写入到新文件中。如下代码演示了拷贝文件的核心代码

```c title="copy1.c" hl:9-13
/**
 * copy1.py - copy file from src to dst
 */

#include <stdio.h>

int main(void)
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        putchar(ch);
    }
}
```

这里我们引入了一个新的运算符 `!=`，它表示 **不等于**。我们知道字符在计算机中是以位模式形式存在，在 C 语言中，类型 `char` 专门用于存储这种字符型数据。由于字符使用位模式表示，通常将其视为整数，因此类型 `int` 及其变种也可以用于存储字符。

还需要解决如何区分文件中有效数据与输入结束符的问题。在 C 语言中，在没有任何输入的时，`getchar()` 会返回一个与任何字符都不同的值，称为 `EOF(End Of File)`。这里将 `ch` 声明为 `int` 而非 `char` 的原因在于它需要存储任何字符以及 `EOF`。

> [!tip]
> 
> `EOF` 在头文件 `<stdio.h>` 中定义，它是个整型数，其具体数值是什么并不重要，只要它与任何 `char` 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的任何特定的数值

请注意，这里`while` 的控制语句 `(ch = getchar()) != EOF`，其中 `(ch = getchar())` 最外层的括号是必须的。不等于运算符 `!=` 的优先级比赋值运算符 `=` 的优先级要高，这样，在不使用圆括号的情况下关系测试 `!=` 将在赋值 `=` 操作之前执行。换句话说，`ch = getchar() != EOF` 等价于 `ch = (getchar() != EOF)`，这并不是我们希望的结果

```c title="print_eof.c"
/**
 * print_eof.c - A simple program to demonstrate end-of-file (EOF) handling in C.
 */

#include <stdio.h>

int main(void)
{
    int ch = EOF;
    printf("The value of EOF is: %d\n", ch);  // Print the integer value of EOF
    return 0;
}
```

### 1.7.2 字符计数

统计文本文件中的字符数量是常见的，下列程序用于对字符进行计数，它与上面的复制程序类似

```c title="nc1.c"
/**
 * nc.c - count characters in input; 1st version 
 */

#include <stdio.h>

main()
{
    long nc;
    nc = 0;
    while (getchar() != EOF)
        ++nc;
    printf("%ld\n", nc);
}
```

其中，语句 `++nc;`  的功能就是使变量 `nc` 加 $1$，可以使用语句 `nc = nc + 1;` 替代。但语句 `++nc` 更精炼一些，且通常效率也更高

该字符计算程序使用 `long` 类型的变量存储字符数量，而不是使用 `int` 类型。因为 `long` 类型的整数变量至少占 $32$ 位。某些机器上 `int` 与 `long` 类型的尺寸相同，但是在一些机器上，`int` 类型的变量可能只有 $16$ 位。这样，相当小的输入都可能使 `int` 类型的变量溢出。转换说明符 `%ld` 指示 `printf()` 函数其对应参数是 `long` 类型

使用 `double`（双精度浮点数）类型可以处理更大的数字。这里我们使用 `for` 循环来编写

```c title="nc2.c"
/**
 * nc.c - count characters in input; 2st version 
 */

#include <stdio.h>

int main()
{
    double nc;
    for (nc = .0l; getchar() != EOF; nc += 1.0l);
    printf("%.0f\n", nc);
}
```

对于 `float` 与 `double` 类型。`printf` 函数都使用 `%f` 进行说明。`%.0f` 强制不打印小数点和小数部分，因此小数部分的位数为 $0$

在该示例程序中，`for` 语句的循环体是 **空语句**。这是因为所有工作都在控制表达式部分与增加步长部分完成了，但是 C 语言的语法规则要求 `for` 循环语句必须有一个循环体，因此用 **单独的分号** 代替

> [!tip]
> 
> 在 C 语言中，单独的分号也是一条 C 语句，称为 **空语句**

### 1.7.3 行计数

接下来的示例程序用于统计输入中的行数。前面提到过，标准库保证输入文本流以行序列的形式出现，每一行均以换行符结束。因此，统计行数等价于统计换行符的个数

```c title="line.c"
/**
 * line.c - count lines in input
 */

#include <stdio.h>

int main(void)
{
    long nl;
    int ch;
    nl = 0;
    while ((ch = getchar()) != EOF)
        if (ch == '\n')
            ++nl;
    printf("%ld\n", nl);
}
```

在这个示例程序中，`while` 语句的循环体是一个 `if` 语句。它控制自增语句 `++nl`。`if` 语句先测试圆括号中的条件，如果该条件为真，则执行其后的语句（或括在花括号中的一组语句）。注意，这里我们使用缩进方式表明语句之间的控制关系

双等于号 `==` 是 C 语言中表示 **“等于”** 关系的运算符。由于 C 语言将单等于号 `=` 作为赋值运算符，因此使用双等于号 `==` 表示相等的逻辑关系，以示区分

> [!warning] 
> 
> 请特别注意，**在判断两个表达式的值是否相等时，请务必使用双等号 `==`**。如果错误地写成单等于号 `=`，其结果通常仍然是合法的表达式，因此系统不会给出警告信息

单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为 **字符常量**。但是，它只不过是小的整型数的另一种写法而已。例如，`'A'` 是一个字符常量；在 ASCII 字符集中其值为 $65$（即字符 `A` 的内部表示值为 $65$）。当然，用 `'A'` 要比用 $65$ 好，因为 `'A'` 的意义更清楚，且与特定的字符集无关。

字符串常量中使用的转义字符序列也是合法的字符常量，比如，`'\n'` 代表换行符的值，在 ASCII 字符集中其值为 $10$。我们应当注意到，`'\n'` 是单个字符，在表达式中它不过是一个整型数而已；而 `"\n"` 是一个仅包含一个字符的字符串常量

> [!tip]
> 
> 关于字符与字符串，我们将在 [第二章 数据类型](./002-数据类型.md) 中介绍

下面的示例程序用于统计空格、制表符与换行符个数的程序

```c title="space.c"

```
